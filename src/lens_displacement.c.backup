/******************************************************************************/
// Free implementation of Bullfrog's Dungeon Keeper strategy game.
/******************************************************************************/
/** @file lens_displacement.c
 *     Displacement/warping lens effect functions.
 * @par Purpose:
 *     Functions to create and apply displacement/distortion effects to images.
 *     Displacement effects warp the image by reading pixels from different
 *     locations, creating wave, ripple, or fisheye-like distortions.
 * @par Comment:
 *     None.
 * @author   KeeperFX Team
 * @date     09 Feb 2026
 * @par  Copying and copyrights:
 *     This program is free software; you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation; either version 2 of the License, or
 *     (at your option) any later version.
 */
/******************************************************************************/
#include "pre_inc.h"
#include "lens_displacement.h"

#include <math.h>
#include "bflib_basics.h"
#include "globals.h"

#include "post_inc.h"

#ifdef __cplusplus
extern "C" {
#endif

/******************************************************************************/

void init_displacement_map(uint32_t *lens_mem, int width, int height, int pitch, 
                          int algorithm, int magnitude, int period)
{
    long w, h;
    long shift_w, shift_h;
    uint32_t *mem;
    double flwidth, flheight;
    double center_w, center_h;
    double flpos_w, flpos_h;
    double flmag;
    
    switch (algorithm)
    {
    case DisplaceAlgo_Linear:
        // Simple linear offset - not commonly used
        // Each output pixel maps to a fixed offset input pixel
        mem = lens_mem;
        for (h = 0; h < height; h++)
        {
            for (w = 0; w < width; w++)
            {
                *mem = ((h + (height >> 1)) / 2) * pitch + ((w + (width >> 1)) / 2);
                mem++;
            }
        }
        break;
        
    case DisplaceAlgo_Sinusoidal:
        // Sine wave distortion - creates ripple/wave effects
        // Magnitude controls wave amplitude, period controls frequency
        {
            flmag = magnitude;
            double flperiod = period;
            flwidth = width;
            flheight = height;
            center_h = flheight * 0.5;
            center_w = flwidth * 0.5;
            flpos_h = -center_h;
            mem = lens_mem;
            
            for (h = 0; h < height; h++)
            {
                flpos_w = -center_w;
                for (w = 0; w < width; w++)
                {
                    shift_w = (long)(sin(flpos_h / flwidth  * flperiod) * flmag + flpos_w + center_w);
                    shift_h = (long)(sin(flpos_w / flheight * flperiod) * flmag + flpos_h + center_h);
                    
                    // Clamp to valid range
                    if (shift_w >= width)  shift_w = width - 1;
                    if (shift_w < 0)       shift_w = 0;
                    if (shift_h >= height) shift_h = height - 1;
                    if (shift_h < 0)       shift_h = 0;
                    
                    *mem = shift_w + shift_h * pitch;
                    flpos_w += 1.0;
                    mem++;
                }
                flpos_h += 1.0;
            }
        }
        break;
        
    case DisplaceAlgo_Radial:
        // Radial distortion - creates fisheye or pincushion effects
        // Magnitude controls distortion strength, period controls edge behavior
        {
            flmag = magnitude * (double)magnitude;
            flwidth = width;
            flheight = height;
            center_h = flheight * 0.5;
            center_w = flwidth * 0.5;
            double fldivs = sqrt(center_h * center_h + center_w * center_w + flmag);
            flpos_h = -center_h;
            mem = lens_mem;
            
            for (h = 0; h < height; h++)
            {
                flpos_w = -center_w;
                for (w = 0; w < width; w++)
                {
                    // Distance-based radial distortion
                    double fldist = sqrt(flpos_w * flpos_w + flpos_h * flpos_h + flmag) / fldivs;
                    shift_w = (long)(fldist * flpos_w + center_w);
                    shift_h = (long)(fldist * flpos_h + center_h);
                    
                    // Clamp to valid range (period bits control edge clamping behavior)
                    if (shift_w >= width)  shift_w = width - 1;
                    if ((shift_w < 0) || ((period & 1) == 0)) shift_w = 0;
                    if (shift_h >= height) shift_h = height - 1;
                    if ((shift_h < 0) || ((period & 2) == 0)) shift_h = 0;
                    
                    *mem = shift_w + shift_h * pitch;
                    flpos_w += 1.0;
                    mem++;
                }
                flpos_h += 1.0;
            }
        }
        break;
        
    default:
        ERRORLOG("Unknown displacement algorithm %d", algorithm);
        break;
    }
}

void draw_displacement_lens(unsigned char *dstbuf, unsigned char *srcbuf, 
                           uint32_t *lens_mem, int width, int height, 
                           int dstpitch, int lens_pitch)
{
    SYNCDBG(16, "Applying displacement");
    unsigned char *dst = dstbuf;
    uint32_t *mem = lens_mem;
    
    // srcbuf is the full screen buffer - pos_map indexes into it correctly
    // lens_pitch is the width of the displacement map (full screen width)
    for (int h = 0; h < height; h++)
    {
        for (int w = 0; w < width; w++)
        {
            long pos_map = *mem;
            dst[w] = srcbuf[pos_map];
            mem++;
        }
        dst += dstpitch;
        // Skip to the next row in the displacement map if it's wider than our render width
        mem += (lens_pitch - width);
    }
}

/******************************************************************************/
#ifdef __cplusplus
}
#endif
