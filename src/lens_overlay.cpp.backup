/******************************************************************************/
// Free implementation of Bullfrog's Dungeon Keeper strategy game.
/******************************************************************************/
/** @file lens_overlay.cpp
 *     Overlay (graphics compositing) lens effect implementation.
 * @par Purpose:
 *     Provides overlay/compositing functionality for lens effects.
 * @par Comment:
 *     Extracted from lens_api.c as part of modularization effort.
 * @author   KeeperFX Team
 * @date     09 Feb 2026
 * @par  Copying and copyrights:
 *     This program is free software; you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation; either version 2 of the License, or
 *     (at your option) any later version.
 */
/******************************************************************************/
#include "pre_inc.h"

#include "lens_overlay.h"

#include <string.h>
#include "bflib_basics.h"
#include "bflib_fileio.h"
#include "bflib_dernc.h"
#include "globals.h"
#include "config_lenses.h"
#include "config_mods.h"

#include "post_inc.h"

/******************************************************************************/
/** Structure to hold cached overlay image data */
struct OverlayImageCache {
    unsigned char* data;         // Overlay image data (64x64)
    short alpha;                 // Alpha blending level (0-256)
    TbBool loaded;               // Whether this cache slot is loaded
};

/******************************************************************************/
/** Global overlay cache - indexed by lens_idx */
static struct OverlayImageCache overlay_cache[MAX_OVERLAY_CACHE];

/******************************************************************************/
/**
 * Helper: Load file from mods with fallback to base game data.
 * Similar to the implementation in lens_api.c.
 */
static TbBool load_overlay_file_with_fallback(const char* fname_base, unsigned char* buffer, 
                                               size_t expected_size)
{
    // Try loading from all loaded mods' data directories first
    for (int i = 0; i < mods_conf.after_base_cnt; i++) {
        const struct ModConfigItem* mod_item = &mods_conf.after_base_item[i];
        // Only check mods that have a directory (mod_dir flag)
        if (mod_item->state.mod_dir) {
            char mod_dir[256];
            snprintf(mod_dir, sizeof(mod_dir), "%s/%s", MODS_DIR_NAME, mod_item->name);
            char* fname_mod = prepare_file_path_mod(mod_dir, FGrp_StdData, fname_base);
            
            // Check if file exists first
            if (LbFileExists(fname_mod)) {
                long file_size = LbFileLengthRnc(fname_mod);
                
                // Only load if file size matches expected size
                if (file_size == expected_size) {
                    long loaded = LbFileLoadAt(fname_mod, buffer);
                    if (loaded == expected_size) {
                        SYNCDBG(7, "Loaded overlay '%s' from mod '%s'", fname_base, mod_item->name);
                        return true;
                    }
                } else {
                    WARNLOG("Overlay file '%s' has wrong size: %ld bytes (expected %lu bytes)", 
                            fname_mod, file_size, (unsigned long)expected_size);
                }
            }
        }
    }
    
    // If not found in mods, try base game directory
    char* fname_base_path = prepare_file_path(FGrp_StdData, fname_base);
    if (LbFileExists(fname_base_path)) {
        long file_size = LbFileLengthRnc(fname_base_path);
        
        if (file_size == expected_size) {
            long loaded = LbFileLoadAt(fname_base_path, buffer);
            if (loaded == expected_size) {
                SYNCDBG(7, "Loaded overlay '%s' from base game", fname_base);
                return true;
            }
        } else {
            WARNLOG("Overlay file '%s' has wrong size: %ld bytes (expected %lu bytes)", 
                    fname_base_path, file_size, (unsigned long)expected_size);
        }
    }
    
    return false;
}

/******************************************************************************/
void init_overlay_system(void)
{
    SYNCDBG(7, "Initializing overlay system");
    
    // Clear the overlay cache
    for (int i = 0; i < MAX_OVERLAY_CACHE; i++) {
        overlay_cache[i].data = NULL;
        overlay_cache[i].alpha = 128;  // Default 50% alpha
        overlay_cache[i].loaded = false;
    }
}

void cleanup_overlay_system(void)
{
    SYNCDBG(7, "Cleaning up overlay system");
    
    // Free all cached overlay data
    for (int i = 0; i < MAX_OVERLAY_CACHE; i++) {
        if (overlay_cache[i].data != NULL) {
            free(overlay_cache[i].data);
            overlay_cache[i].data = NULL;
        }
        overlay_cache[i].loaded = false;
    }
}

void free_overlay_image(long lens_idx)
{
    if (lens_idx < 0 || lens_idx >= MAX_OVERLAY_CACHE) {
        WARNLOG("Invalid lens index for overlay: %ld", lens_idx);
        return;
    }
    
    if (overlay_cache[lens_idx].data != NULL) {
        SYNCDBG(8, "Freeing overlay for lens %ld", lens_idx);
        free(overlay_cache[lens_idx].data);
        overlay_cache[lens_idx].data = NULL;
    }
    overlay_cache[lens_idx].loaded = false;
}

TbBool load_lens_overlay(long lens_idx)
{
    if (lens_idx < 0 || lens_idx >= MAX_OVERLAY_CACHE) {
        WARNLOG("Invalid lens index for overlay: %ld", lens_idx);
        return false;
    }
    
    // Get lens configuration
    struct LensConfig* cfg = get_lens_config(lens_idx);
    if (cfg == NULL) {
        WARNLOG("Failed to get lens config for index %ld", lens_idx);
        return false;
    }
    
    // Check if this lens has an overlay effect
    if ((cfg->flags & LCF_HasOverlay) == 0) {
        SYNCDBG(8, "Lens %ld does not have overlay effect", lens_idx);
        return false;
    }
    
    // Free any existing overlay in this cache slot
    free_overlay_image(lens_idx);
    
    // Allocate memory for overlay image (64x64 pixels)
    const size_t overlay_size = OVERLAY_SPRITE_SIZE * OVERLAY_SPRITE_SIZE;
    overlay_cache[lens_idx].data = (unsigned char*)malloc(overlay_size);
    
    if (overlay_cache[lens_idx].data == NULL) {
        ERRORLOG("Failed to allocate memory for overlay (lens %ld)", lens_idx);
        return false;
    }
    
    // Load overlay file from mods or base game
    if (!load_overlay_file_with_fallback(cfg->overlay_file, overlay_cache[lens_idx].data, overlay_size)) {
        WARNLOG("Failed to load overlay file '%s' for lens %ld", cfg->overlay_file, lens_idx);
        free_overlay_image(lens_idx);
        return false;
    }
    
    // Store alpha value from config
    overlay_cache[lens_idx].alpha = cfg->overlay_alpha;
    overlay_cache[lens_idx].loaded = true;
    
    SYNCDBG(7, "Successfully loaded overlay '%s' for lens %ld (alpha: %d)", 
            cfg->overlay_file, lens_idx, cfg->overlay_alpha);
    
    return true;
}

void draw_lens_overlay(unsigned char *dstbuf, long dstpitch, long width, long height, long lens_idx)
{
    if (lens_idx < 0 || lens_idx >= MAX_OVERLAY_CACHE) {
        return;
    }
    
    // Check if overlay is loaded for this lens
    if (!overlay_cache[lens_idx].loaded || overlay_cache[lens_idx].data == NULL) {
        return;
    }
    
    const unsigned char* overlay_src = overlay_cache[lens_idx].data;
    const short alpha = overlay_cache[lens_idx].alpha;
    
    // Calculate centering offsets (overlay is 64x64, viewport might be different)
    const int overlay_w = OVERLAY_SPRITE_SIZE;
    const int overlay_h = OVERLAY_SPRITE_SIZE;
    const int offset_x = (width - overlay_w) / 2;
    const int offset_y = (height - overlay_h) / 2;
    
    // Clamp alpha to valid range (0-256, where 256 = opaque)
    int alpha_clamped = (alpha < 0) ? 0 : ((alpha > 256) ? 256 : alpha);
    int inv_alpha = 256 - alpha_clamped;
    
    // Composite overlay onto destination buffer
    for (int y = 0; y < overlay_h; y++) {
        int dst_y = offset_y + y;
        // Skip rows outside viewport
        if (dst_y < 0 || dst_y >= height) {
            continue;
        }
        
        for (int x = 0; x < overlay_w; x++) {
            int dst_x = offset_x + x;
            // Skip columns outside viewport
            if (dst_x < 0 || dst_x >= width) {
                continue;
            }
            
            // Get overlay pixel
            unsigned char overlay_pixel = overlay_src[y * overlay_w + x];
            
            // Get destination pixel
            unsigned char* dst_pixel_ptr = dstbuf + dst_y * dstpitch + dst_x;
            unsigned char dst_pixel = *dst_pixel_ptr;
            
            // Alpha blend: result = (overlay * alpha + dst * (1 - alpha)) / 256
            unsigned char blended = (unsigned char)(
                (overlay_pixel * alpha_clamped + dst_pixel * inv_alpha) >> 8
            );
            
            // Write blended pixel back to destination
            *dst_pixel_ptr = blended;
        }
    }
}

/******************************************************************************/
